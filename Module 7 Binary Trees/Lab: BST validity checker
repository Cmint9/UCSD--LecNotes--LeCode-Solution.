# This is lab instruction: 
Step 1: Inspect the Node.py file
Inspect the class declaration for a BST node in Node.py. Access Node.py by clicking on the orange arrow next to main.py at the top of the coding window. Each node has a key, a left child reference, and a right child reference.

Step 2: Implement the check_bst_validity() function
Implement the check_bst_validity() function in the BSTChecker.py file. The function takes the tree's root node as a parameter and returns the node that violates BST requirements, or None if the tree is a valid BST.

A violating node X will meet one or more of the following conditions:

X is in the left subtree of ancestor Y, but X's key is > Y's key
X is in the right subtree of ancestor Y, but X's key is < Y's key
X's left or right child references an ancestor
Note: Other types of BST violations can occur, but are not covered in this lab.

The given code in main.py reads and parses input and builds the tree for you. Nodes are presented in the form (key, left_child, right_child), where left_child and right_child can be nested nodes or None. A leaf node is of the form (key). After parsing tree input, the check_bst_validity() function is called and the returned node's key (or "None") is printed.

Ex:
Tree 1 with 60 node violation

If the input is:

(50, (25, None, (60)), (75)
which corresponds to the tree above, then the output is:

60
because 60 violates BST requirements by being in the left subtree of 50.


Follow module 7, we get some basic ideas and algorithms to solve this lab.


Ex:
Tree 1 with 60 node violation

If the input is:

(20, (10), (30, (29), (31)))
which corresponds to the tree above, then the output is:

None
because all BST requirements are met.

The input format doesn't allow creating a tree with a node's child referencing an ancestor, so unit tests are used to test such cases.
